# -*- coding: utf-8 -*-
"""Submission Predictive Analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zRYanYpu-2V7LF9VqkYQxDeHrq570fh_

# **Predictive Analytic - Klasifikasi Diabetes**

- **Nama:** Duma Mora Arta Sitorus
- **Email:** dumamora5@gmail.com
- **ID Dicoding:** duma_mora

1.   **Deskripsi Proyek:** Membangun model machine learning yang dapat melakukan prediksi terhadap data untuk menetukan apakah seseorang mengidap penyakit diabetes atau tidak.

2.   **Dataset:** Dataset yang digunakan diperoleh dari repository penyedia dataset [Kagle](https://www.kaggle.com/) yang bernama [Pima Indians Diabetes Database](https://www.kaggle.com/datasets/uciml/pima-indians-diabetes-database).

  Data berasal dari Institut Nasional Penyakit Diabetes, Pencernaan, dan Ginjal. Dataset ini dapat digunakan untuk memprediksi secara diagnostik apakah seorang pasien menderita diabetes atau tidak berdasarkan pengukuran diagnostik seperti jumlah kehamilan, kadar glukosa, tekanan darah, ketebalan kulit, kadar insulin, BMI, fungsi silsilah diabetes, serta usia(tahun).

  Data yang terdapat dalam dataset tersebut diambil dari pasien berjenis kelamin perempuan berusia minimal 21 tahun dan merupakan keturunan Indian Pima.

3.   **Fitur Dataset:** Dataset terdiri dari 9 fitur (8 variabel + 1 target) dan 768 data pengukuran. Fittur pada dataset adalah sebagai berikut:
  *   **pregnancies**: Jumlah kehamilan
  *   **Glucose**: Kadar glukosa (gula) dalam plasma darah setelah 2 jam menjalani Oral Glucose Tolerance Test (OGTT).
  *   **BloodPressure**: Tekanan darah diastolik  dalam satuan mm Hg
  *   **SkinThickness**: Tebal lipatan kulit pada bagian Trisep (lengan atas belakang) dalam satuan milimeter(mm).
  *   **Insulin**: Kadar insulin dalam darah selama 2 jam setelah melakukan OGTT, diukur dalam satuan mikro unit/milimeter(mU/ml)
  *   **BMI**:Body Mass Index (menyatakan proporsional berat badan terhadap tinggi badan seseorang) dalam satuan kilogram/meter persegi(kg/m^2)
  *   **DiabetesPedigreeFunction**: Ukuran probabilitas turunan genetik terhadap diabetes
  *   **Age**: Usia dalam tahun
  *   **Outcome**: bernilai 0 (untuk yang bukan penderita diabetes) dan 1 (untuk penderita diabetes).

## **1. Import Library**

Pada tahap ini, dilakukan import beberapa pustaka (library) Python yang dibutuhkan untuk analisis data, pembangunan model machine learning, dan evaluasi.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from imblearn.over_sampling import SMOTE
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.svm import SVC
from sklearn.ensemble import AdaBoostClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_auc_score, precision_score, recall_score, f1_score

"""## **2. Data Loading**"""

diabetes_df = pd.read_csv("https://raw.githubusercontent.com/DumaSitorus/diabetes-predictive-analysis/refs/heads/main/data/diabetes.csv")
diabetes_df.head()

"""## **3. Exploratory Data Analysis**

### **Eksplorasi Dataset**
"""

diabetes_df.info()

"""**Hasil Analisis:**


*   Data set terdiri dari 9 variabel dengan 1 variabel target yaitu outcome.
*   Dataset terdiri atas 768 baris data yang bertipe integer dan float.
*   Dataset tidak memiliki missing value sehingga tidak perlu melakukan penanganan missing value.


"""

diabetes_df.describe()

"""**Hasil Analisis:**


**1.   Pregnancies:**
  *   Jumlah kehamilan minimal pasien adalah 0. Hal ini mungkin karena pasien belum menikah atau belum pernah melahirkan sebelumnya.
  *   Jumlah kehamilan terbanyak adalah 17. Data ini diragukan dan mengindikasikan kemungkinan outlier sehingga perlu pemeriksaan dengan analisis lanjutan terhadap outlier pada data.
  *   Rata-rata jumlah kehamilan adalah 4 kali (hasil pembulatan)

**2.   Glucose:**
  *   Jumlah kadar gula darah minimal pasien dalam dataset adalah 0. Hal ini tidak mungkin secara biologis, kemungkinan terjadi data error karena missing value sehingga perlu penanganan lebih lanjut.
  *   Jumlah kadar gula darah terbanyak adalah 199. meskipun angka ini sangat tinggi tapi ini mungkin saja terjadi.
  *   Rata-rata jumlah kehamilan adalah 120.89 mg/dL.

**3.   BloodPressure:**
  *   Jumlah Tekanan darah terendah pasien adalah 0 mmHg. Hal ini tidak mungkin secara biologis, kemungkinan terjadi data error karena missing value sehingga perlu penanganan lebih lanjut.
  *   Jumlah tekanan darah tertinggi adalah 122 mmHg. Data ini diragukan dan mengindikasikan kemungkinan outlier sehingga perlu pemeriksaan dengan analisis lanjutan terhadap outlier pada data.
  *   Rata-rata tekanan darah adalah 69.105469 mmHg.

**4.   SkinThickness:**
  *   Jumlah Skin Thickness terkecil pasien adalah 0. Hal ini tidak mungkin karena manusia pasti memiliki lemak, kemungkinan terjadi data error karena missing value sehingga perlu penanganan lebih lanjut.
  *   Jumlah Skin Thickness terbesar adalah 99 mm (hampir 10cm). Hal ini mungkin saja akan tetapi sangat jarang kecuali pasien merupakan pasien obesitas parah. Sehingga data ini diragukan dan mengindikasikan outlier dan perlu pemeriksaan dengan analisis lebih lanjut.
  *   Rata-rata Skin Thickness adalah 20.5 mm.

**5.   Insulin:**
  *   kadar insulin minimal pasien adalah 0 mU/ml. Hal ini mungkin terjadi jika pankreas sama sekali tidak memproduksi insulin yang dapat terjadi pada penderita diabetes tipe 1 berat. akan tetapi perlu dilakukan pemeriksaan lebih lanjut untuk memastikan tidak adanya data error karena missing value.
  *   kadar insulin terbanyak adalah 846 mU/ml. Hal ini mungkin terjadi pada kondisi dimana pasien memiliki masalah pada pankreas yang menyebabkan peningkatan produksi insulin seperti pada penderita tumor pankreas, obesitas, sindrom metabolik berat. Namun memungkinkan juga terjadi kekeliruan dalam data. sehingga perlu pemeriksaan dengan analisis lanjutan terhadap outlier pada data.
  *   Rata-rata kadar insulin adalah 79.79 mU/ml.

**6.   BMI:**
  *   BMI minimal pasien adalah 0 kg/m^2. 0. Hal ini sangat tidak mungkin, kemungkinan terjadi data error karena missing value sehingga perlu penanganan lebih lanjut.
  *   BMI tertinggi adalah 67.1 kg/m^2. Data cukup tinggi tetapi mungkin terjadi pada penderita diabetes ekstrim, diperlukan analisis lanjutan terhadap outlier pada data BMI.
  *   Rata-rata BMI adalah 31.99 kg/m^2.

**7.   DiabetesPedigreeFunction:**
  *   Probabilitas turunan genetik penderita diabetes terkecil adalah 0. Hal ini mungkin terjadi.
  *   Probabilitas tujutann genetik penderita diabetes tertinggi adalah 2.42. Hal ini mungkin saja terjadi namun masih sangat tinggi sehingga perlu pemeriksaan kemungkinan outlier lebih lanjut.
  *   Rata-rata Probabilitas turunan genetik penderita diabetes dalam dataset adalah 0.47.

**8.   Age:**
  *   Usia pasien yang dilakukan pengukuran diagnostik berkisar dari 21-81 tahun.
  *   Rata-rata usia pasien adalah 33 tahun (hasil pembulatan)

**9.   Outcome:**
  *   Bernilai 1 jika pasien menderita diabetes
  *   Bernilai 0 jika pasien tidak menderita diabetes

Kesimpulan:
- Terdapat indikasi error data pada fitur Glucose, BloodPressure, SkinThickness, Insulin, BMI, DiabetesPedigreeFunction. Hal ini perlu ditelusuri lebih lanjut untuk menjamin kualitas data yang akan dilatih.
- Terdapat indikasi data outlier pada fitur Pregnancies, BloodPressure, SkinThickness, Insulin, BMI, DiabetesPedigreeFunction. Hal ini perlu ditangani lebih lanjut untuk menjaga performa model prediksi yang dihasilkan nantinya.

### **Cek Proporsi Fitur Outcome**
"""

ax = sns.countplot(x='Outcome', palette="Greens", data=diabetes_df)

# jumlah data per unik value
for p in ax.patches:
    ax.annotate(f'{p.get_height()}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                fontsize=12, color='black',
                xytext=(0, 5), textcoords='offset points')

# plot
plt.title('Distribusi Outcome Diabetes')
plt.xlabel('Outcome')
plt.ylabel('Jumlah')
plt.show()

"""**Insight:**

Data dengan outcome 0 (tidak menderita diabetes hampir 2 kali lebih banyak dibandingkan dengan outcome bernilai 1 (menderita diabetes).

Hal ini bisa berpengaruh pada saat proses pelatihan dimana model lebih hafal dengan data yang dominan dan gagal memprediksi data minoritas.

Sehingga, diperlukan penanganan untuk menyeimbangkan proporsi data atau pemilihan algoritma yang yang tahan akan imbalance data.

Opsi Solusi:
- Resampling data dengan melakukan Oversampling maupun Undersampling.
- Memilih algoritma yang tahan terhadap imbalanced data.

### **Cek distribusi data dengan visualisasi Histogram**
"""

# plot histogram
diabetes_df.hist(figsize=(15,10))
plt.tight_layout()
plt.show()

"""**Insight:**
1.   Pregnancies:
  *   Distribusi skew ke kanan.
  *   Sebagian besar pasien dengan jumlah kehamilan 0-3 kali
  *   Terdapat sejumlah pasien dengan jumlah kehamilan tinggi (lebih dari 10 kali)
  *   Dapat melakukan normalisasi serta penanganan outlier.

2.   Glucose:
  *   Distribusi normal
  *   Kebanyakan pasien dengan kadar glukosa berkisar 80-150
  *   Distribusi fitur ini cukup bagus untuk klasifikasi

3.   BloodPressure:
  *   Distribusi normal, tetapi terdapat data dengan nilai 0 sehingga tidak sepenuhnya normal.
  *   Kebanyakan pasien dengan tekanan darah distolik 60-80 mmHg.
  *   Diperlukan penanganan pada nilai 0 baik dengan imputasi maupun drop data.

4.   SkinThickness:
  *   Distribusi skew ke kanan dan masih terdapat data dengan nilai 0.
  *   Diperlukan penanganan pada nilai 0 baik dengan imputasi maupun drop data.


5.   Insulin:
  *   Distribusi skew ke kanan, terdapat nilai 0, dan nilai yang cukup ekstream (kemungkinan outlier)
  *   Diperlukan penanganan pada nilai 0 dan outlier

6.   BMI:
  *   Distribusi hampir normal
  *   Kebanyakan pasien dengan BMI antara 25-40
  *   Diperlukan penanganan pada nilai 0 baik dengan imputasi maupun drop data.

7.   DiabetesPedigreeFunction:
  *   Distribusi sanagt skew ke kanan

8.   Age:
  *   Distribusi skew ke kanan
  *   semakin tua usia, semakin sedikit jumlah pasien

9.   Outcome:
  *   Distribusi tidak seimbang

### **Cek korelasi data dengan visualisasi Heatmap**
"""

# hitung correlation matrix
correlation_matrix = diabetes_df.corr()

# Plot Heatmap
plt.figure(figsize=(10, 8))  # Mengatur ukuran figure
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Correlation Heatmap')
plt.show()

"""Insight:


*   Kadar glukosa menunjukkan pengaruh yang tertinggi terhadap outcome dibandingkan dengan fitur lainnya. Korelasi positif cukup kuat, artinya semakin tinggi kadar glukosa maka semakin besar kemungkinan diabetes.

*  Jumlah produksi Insulin dan skin thickness menunjukkan korelasi positf yang moderat. sehingga orang dengan insulin tinggi cenderung memiliki ketebalan kulit yang lebih besar.

*   Pregnancies dan Age memiliki korelasi positif yang cukup kuat yang menunjukkan semakin tua, semakin banyak kehamilan biasanya.

*  Secara keseluruhan tidak terdapat korelasi fitur yang sangat tinggi (>0.75) sehingga tidak perlu melakukan drop fitur karena multikolinearitas.

### **Cek Outlier di setiap fitur**
"""

# boxplot
plt.figure(figsize=(20, 15))

for i, column in enumerate(diabetes_df.columns, 1):
    plt.subplot(3, 3, i)
    sns.boxplot(y=diabetes_df[column])
    plt.title(f'Boxplot of {column}')

plt.tight_layout()
plt.show()

"""**Insight:**



*   Fitur Pregnancies memiliki beberapa outlier diatas yang bernilai >13.
*   Fitur Glucose memiliki outlier dengan nilai ekstrem (0), kemungkinan nilai ini tidak valid.
*   Fitur BloodPreasure memiliki beberapa outlier  dibawah dengan nilai ekstream mencapai 0, ini tidak masuk akal dan mengindikasikan invalid value.
*   Fitur Skin Thickness memiliki outlier dengan nilai yang sangat tinggi.
*   Fitur Insulin memiliki sangat banyak data outlier dengan nilai yang sangat tinggi
*   Fitur BMI memiliki cukup banyak outlier dengan nilai yang sangat tinggi dan terdapat juga outlier dengan nilai sangat kecil yaitu 0 yang kemungkinan merupakan invalid value.
*   Fitur DiabetesPredigreeFunction memiliki sangat banyak data outlier dengan nilai yang tinggi
*   Fitur Age memiliki beberapa outlier dengan nilai yang tinggi
*   Fitur outcome tidak memiliki outlier.

## **4. Data Preparation**

### **Data Treatment**

#### **1. Penanganan Invalid data**

##### **Invalid data Glucose**
"""

glucose_zero = diabetes_df[diabetes_df['Glucose'] == 0]
print(glucose_zero.to_string())

"""Catatan: Terdapat 5 (kecil) data dengan Glucosa bernilai 0. Maka dilakukan drop data."""

print(f"Jumlah data sebelum: {len(diabetes_df)}")
diabetes_df = diabetes_df[diabetes_df['Glucose'] != 0]
print(f"Jumlah data sesudah: {len(diabetes_df)}")

"""##### **Invalid data BMI**"""

BMI_zero = diabetes_df[diabetes_df['BMI'] == 0]
print(BMI_zero.to_string())

"""Catatan: Terdapat 8 (kecil) data dengan BMI bernilai 0. Maka dilakukan drop data."""

print(f"Jumlah data sebelum: {len(diabetes_df)}")
diabetes_df = diabetes_df[diabetes_df['BMI'] != 0]
print(f"Jumlah data sesudah: {len(diabetes_df)}")

"""##### **Invalid data BloodPressure**"""

BloodPressure_zero = diabetes_df[diabetes_df['BloodPressure'] == 0]
print(BloodPressure_zero.to_string())
print(f"Jumlah pasien dengan BloodPressure = 0: {len(BloodPressure_zero)}")

"""Catatan: Terdapat 28 baris data dengan Tekanan darah bernilai 0. Jika diperhatikan lagi, pada banyak invalid value dengna nilai serupa (0) pada kolom Skin Thickness dan Insulin.
Sebaiknya dilakukan drop data.
"""

print(f"Jumlah data sebelum: {len(diabetes_df)}")
diabetes_df = diabetes_df[diabetes_df['BloodPressure'] != 0]
print(f"Jumlah data sesudah: {len(diabetes_df)}")

"""##### **Invalid data SkinThickness**"""

SkinThickness_zero = diabetes_df[diabetes_df['SkinThickness'] == 0]
print(SkinThickness_zero.to_string())
print(f"Jumlah pasien dengan SkinThickness = 0: {len(SkinThickness_zero)}")

"""Catatan: Terdapat 192 baris data dengan Skin Thickness bernilai 0. Nilai ini cukup tinggi. Sebaiknya dilakukan imputasi agar tidak kehilangan banyak data jika melakukan drop data.
Imputasi akan menggunakan median dari data yang valid (!=0).
"""

# hitung Q1, Q3, dan IQR
valid_skin = diabetes_df[diabetes_df['SkinThickness'] != 0]['SkinThickness']

Q1 = valid_skin.quantile(0.25)
Q3 = valid_skin.quantile(0.75)
IQR = Q3 - Q1

# imputasi dengan median
median_skin = valid_skin.median()
print(f"Median SkinThickness: {median_skin}")

# proses imputasi
diabetes_df['SkinThickness'] = diabetes_df['SkinThickness'].replace(0, median_skin)

# cek apakah masih terdapat invalid value
print(f"Jumlah 0 setelah imputasi: {(diabetes_df['SkinThickness'] == 0).sum()}")

"""##### **Invalid data Insulin**"""

Insulin_zero = diabetes_df[diabetes_df['Insulin'] == 0]
print(Insulin_zero.to_string())
print(f"Jumlah pasien dengan kadar Insulin = 0: {len(Insulin_zero)}")

"""Catatan: Terdapat 332 baris data dengan Insulin bernilai 0. Jumlah ini cukup tinggi. Sebaiknya dilakukan imputasi agar tidak kehilangan banyak data jika melakukan drop data.
Imputasi akan menggunakan metode IQR untuk menghilangkan outlier dan mengimputasi dengan median dari data tanpa outlier.
"""

# hitung Q1, Q3, dan IQR
valid_insulin = diabetes_df['Insulin']

Q1 = valid_insulin.quantile(0.25)
Q3 = valid_insulin.quantile(0.75)
IQR = Q3 - Q1

# filter outlier berdasarkan IQR
filtered_insulin = valid_insulin[(valid_insulin >= Q1 - 1.5 * IQR) &
                                 (valid_insulin <= Q3 + 1.5 * IQR)]

# hitung median dari data yang sudah bersih dari outlier
clean_median = filtered_insulin.median()
print(f"Median Insulin setelah outlier removal: {clean_median}")

# Imputasi nilai 0 dengan median yang bersih dari outlier
diabetes_df['Insulin'] = diabetes_df['Insulin'].replace(0, clean_median)

# cek apakah masih terdapat invalid value
print(f"Jumlah nilai 0 setelah imputasi: {(diabetes_df['Insulin'] == 0).sum()}")

diabetes_df.head(20)

"""#### **2. Penanganan Outlier**

##### **Outlier Pregnancies**
"""

# hitung Q1, Q3, dan IQR untuk kolom Pregnancies
Q1 = diabetes_df['Pregnancies'].quantile(0.25)
Q3 = diabetes_df['Pregnancies'].quantile(0.75)
IQR = Q3 - Q1

# batas bawah dan atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# filter data untuk hanya menampilkan outlier
outliers = diabetes_df[(diabetes_df['Pregnancies'] < lower_bound) |
                       (diabetes_df['Pregnancies'] > upper_bound)]

# tabel outlier
print(outliers[['Pregnancies', 'Age', 'Outcome']])

print(f"Jumlah data sebelum menghapus outlier: {len(diabetes_df)}")

# drop outlier
diabetes_df = diabetes_df[(diabetes_df['Pregnancies'] >= lower_bound) &
                                  (diabetes_df['Pregnancies'] <= upper_bound)]

# yampilkan data setelah outlier dihapus
print(f"\nJumlah data setelah menghapus outlier: {len(diabetes_df)}")

"""##### **Outlier BloodPressure**"""

Q1 = diabetes_df['BloodPressure'].quantile(0.25)
Q3 = diabetes_df['BloodPressure'].quantile(0.75)
IQR = Q3 - Q1

# batas bawah dan atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# filter data untuk hanya menampilkan outlier
outliers = diabetes_df[(diabetes_df['BloodPressure'] < lower_bound) |
                       (diabetes_df['BloodPressure'] > upper_bound)]

# tampilkan tabel outlier
print(outliers[['BloodPressure', 'Outcome']])

diabetes_df['BloodPressure'] = diabetes_df['BloodPressure'].apply(
    lambda x: upper_bound if x > upper_bound else (lower_bound if x < lower_bound else x)
)

outliers = diabetes_df[(diabetes_df['BloodPressure'] < lower_bound) |
                       (diabetes_df['BloodPressure'] > upper_bound)]

print(outliers[['BloodPressure', 'Outcome']])

"""##### **Outlier SkinThickness**"""

Q1 = diabetes_df['SkinThickness'].quantile(0.25)
Q3 = diabetes_df['SkinThickness'].quantile(0.75)
IQR = Q3 - Q1

# batas bawah dan atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter data untuk hanya menampilkan outlier
outliers = diabetes_df[(diabetes_df['SkinThickness'] < lower_bound) |
                       (diabetes_df['SkinThickness'] > upper_bound)]

# tampilkan tabel outlier
print(outliers[['SkinThickness', 'Outcome']])

diabetes_df['SkinThickness'] = diabetes_df['SkinThickness'].apply(
    lambda x: upper_bound if x > upper_bound else (lower_bound if x < lower_bound else x)
)

outliers = diabetes_df[(diabetes_df['SkinThickness'] < lower_bound) |
                       (diabetes_df['SkinThickness'] > upper_bound)]

print(outliers[['SkinThickness', 'Outcome']])

"""##### **Outlier Insulin**"""

Q1 = diabetes_df['Insulin'].quantile(0.25)
Q3 = diabetes_df['Insulin'].quantile(0.75)
IQR = Q3 - Q1

# batas bawah dan atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter data untuk hanya menampilkan outlier
outliers = diabetes_df[(diabetes_df['Insulin'] < lower_bound) |
                       (diabetes_df['Insulin'] > upper_bound)]

# Tampilkan tabel outlier
print(outliers[['Insulin', 'Outcome']])

diabetes_df['Insulin'] = diabetes_df['Insulin'].apply(
    lambda x: upper_bound if x > upper_bound else (lower_bound if x < lower_bound else x)
)

outliers = diabetes_df[(diabetes_df['Insulin'] < lower_bound) |
                       (diabetes_df['Insulin'] > upper_bound)]

print(outliers[['Insulin', 'Outcome']])

"""##### **Outlier BMI**"""

Q1 = diabetes_df['BMI'].quantile(0.25)
Q3 = diabetes_df['BMI'].quantile(0.75)
IQR = Q3 - Q1

# Tentukan batas bawah dan atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter data untuk hanya menampilkan outlier pada kolom Pregnancies
outliers = diabetes_df[(diabetes_df['BMI'] < lower_bound) |
                       (diabetes_df['BMI'] > upper_bound)]

# Tampilkan tabel outlier
print(outliers[['BMI', 'Outcome']])

# boxplot
plt.figure(figsize=(20, 15))

for i, column in enumerate(diabetes_df.columns, 1):
    plt.subplot(3, 3, i)
    sns.boxplot(y=diabetes_df[column])
    plt.title(f'Boxplot of {column}')

plt.tight_layout()
plt.show()

"""#### **3. Penanganan Imbalance Data**"""

ax = sns.countplot(x='Outcome', palette="Greens", data=diabetes_df)

# jumlah data per unik value
for p in ax.patches:
    ax.annotate(f'{p.get_height()}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                fontsize=12, color='black',
                xytext=(0, 5), textcoords='offset points')

# plot
plt.title('Distribusi Outcome Diabetes')
plt.xlabel('Outcome')
plt.ylabel('Jumlah')
plt.show()

"""Catatan: Distribusi Outcome menunjukkan imbelance data dimana data bernilai 0 (tidak mengidap diabetes) berjumlah hampir 2 kali lipat dari data lainnya.
Akan dilakukan Resampling terhdapa data minoritas agar menghasilkan jumlah data yang seimbang di setiap outcome. Metode yang digunakan adalah SMOTE (Synthetic Minority Over-sampling Technique). Dengan metode ini akan menghasilkan data baru pada kelas minoritas yaitu oucome = 1 tanpa mengubah variasi atau informasi pada data asli.
"""

# pisahkan fitur dan target
X = diabetes_df.drop('Outcome', axis=1)
y = diabetes_df['Outcome']

# terapkan SMOTE
smote = SMOTE(sampling_strategy='auto', random_state=42)
X_resampled, y_resampled = smote.fit_resample(X, y)

# gabungkan kembali fitur dan target setelah SMOTE
diabetes_df_balanced_smote = pd.DataFrame(X_resampled, columns=X.columns)
diabetes_df_balanced_smote['Outcome'] = y_resampled

# visualisasi distribusi setelah penyeimbangan
ax = sns.countplot(x='Outcome', palette="Greens", data=diabetes_df_balanced_smote)

# jumlah data per unik value
for p in ax.patches:
    ax.annotate(f'{p.get_height()}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                fontsize=12, color='black',
                xytext=(0, 5), textcoords='offset points')

# plot
plt.title('Distribusi Outcome Diabetes setelah SMOTE')
plt.xlabel('Outcome')
plt.ylabel('Jumlah')
plt.show()

"""### **Data Splitting**"""

# pisahkan fitur dan target
X = diabetes_df_balanced_smote.drop('Outcome', axis=1)
y = diabetes_df_balanced_smote['Outcome']  # Kolom target

# split menjadi train dan test set
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# cek ukuran hasil split data
print(f"Training data: {X_train.shape[0]} samples")
print(f"Test data: {X_test.shape[0]} samples")

"""## **5. Model Development**

Pada tahap ini, akan dilakukan pengembangan model machine learning dengan tiga algoritma, yang antara lain:

1. SVM
2. Boosting Algorithm (AdaBoostClassifier)
3. Logistic Regression

### **SVM**
"""

svm = SVC(kernel='rbf', probability=True, random_state=55)
svm.fit(X_train, y_train)
y_pred_svm = svm.predict(X_test)

print("SVM Accuracy:", accuracy_score(y_test, y_pred_svm))

# confusion matrix
cm = confusion_matrix(y_test, y_pred_svm)

# plot confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Prediksi: 0', 'Prediksi: 1'], yticklabels=['Aktual: 0', 'Aktual: 1'])
plt.title('Confusion Matrix - SVM')
plt.xlabel('Prediksi')
plt.ylabel('Aktual')
plt.show()

"""### **Boosting Algorithm**"""

boosting = AdaBoostClassifier(learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)
y_pred_boost = boosting.predict(X_test)

print("AdaBoost Accuracy:", accuracy_score(y_test, y_pred_boost))

# confusion matrix
cm = confusion_matrix(y_test, y_pred_boost)

# plot confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Prediksi: 0', 'Prediksi: 1'], yticklabels=['Aktual: 0', 'Aktual: 1'])
plt.title('Confusion Matrix - AdaBoost')
plt.xlabel('Prediksi')
plt.ylabel('Aktual')
plt.show()

"""### **Logistic Regression**"""

# Logistic Regression
log_reg = LogisticRegression(random_state=55)

# melatih model
log_reg.fit(X_train, y_train)

# prediksi pada data test
y_pred = log_reg.predict(X_test)

# print akurasi
print("LogisticRegression Accuracy:", accuracy_score(y_test, y_pred))

# confusion matrix
cm = confusion_matrix(y_test, y_pred)

# plot confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Prediksi: 0', 'Prediksi: 1'], yticklabels=['Aktual: 0', 'Aktual: 1'])
plt.title('Confusion Matrix - Logistic Regression')
plt.xlabel('Prediksi')
plt.ylabel('Aktual')
plt.show()

"""## **6. Evaluasi Model**"""

# dictionary untuk semua model
model_dict = {
    "SVM": svm,
    "AdaBoost": boosting,
    "LogisticRegression": log_reg,

}

# dataframe untuk menyimpan hasil evaluasi
eval_df = pd.DataFrame(columns=["Accuracy", "Precision", "Recall", "F1-Score", "AUC"])

for name, model in model_dict.items():
    y_pred = model.predict(X_test)
    y_proba = model.predict_proba(X_test)[:, 1] if hasattr(model, "predict_proba") else y_pred

    report = classification_report(y_test, y_pred, output_dict=True)
    auc = roc_auc_score(y_test, y_proba)

    eval_df.loc[name] = [
        accuracy_score(y_test, y_pred),
        report['1']['precision'],
        report['1']['recall'],
        report['1']['f1-score'],
        auc
    ]

# print hasil evaluasi
print(eval_df)

"""🔎 **Analisis Evaluasi Hasil Proyek:**

**1. SVM**
- Accuracy model sebesar 0.747368 menunjukkan model berhasil memprediksikan dengan benar sebesar 74% dari total data.
- Precision sebesar 0.771084, berarti model bisa memprediksi apakah mengidap diabetes dengan kemungkinan cukup besar bahwa hasil prediksi benar.
- Recall hanya mencapai 0.6882, berarti banyak kasus diabetes yang salah prediksi.
- F1-Score menunjukkan keseimbangan antara precision dan recall model mencapai 0.727273
- AUC cukup tinggi yaitu 0.863541, ini menunjukkan model cukup baik dalam membedakan kelas 0 dan 1.
- ModelSVM yang dihasilkan cukup mampu membedakan kelas namun cenderung melewatkan kasus diabetes terlihat dari kasus kesalahan prediksi kasus diabetes menjadi tidak diabetes.

**2. Boosting Algorithm (AdaBoostClassifier)**
- Accuracy mencapai 0.831579, berarti model mampu memprediksi 83,2% data dari keseluruhan data dengan benar.
- Precision cukup tinggi yaitu 0.808081, berarti model mungkin benar memprediksikan kasus pengidap diabetes dengan benar cukup tinggi.
- Recall mencapai 0.860215, berarti model mampu mengidentifikasi sekitar 86.0% dari semua kasus diabetes.
- F1-Score mencapai 0.833333, menunjukkan precision dan recall cukup seimbang.
- AUC mencapai 0.881665, berarti model cukup baik dalam membedakan kelas.
- kinerja cukup baik di semua metrik, Recall dan F1-Score yang cukup tinggi menunjukkan kemampuan model yang baik dalam prediksi setiap kelas.

**3. Logistic Regression**
- Akurasi sebesar 0.736842, merupakan yang terkecil dari model lainnya.
-  Precision bernilai 0.736264 cukup rendah dibandingkan model svm dan adaboost.
- Recall mencapai 0.720430 lebih tinggi dari pada model svm, ini berarti model lebih mampu memprediksi kasus diabetes dengan benar dibanding model svm, namun nilai ini cukup baik.
- F1-Score mencapai 0.728261, artinya keseimbangan precision dan recall masih mencapai 72%.
- AUC mencapai 0.804900, model ini cukup dalam membedakan dua kelas.
- Performa rata-rata di semua metrik, tidak terlalu baik tapi kalah dari modeal svm dan adaboost.


---


📑 Rangkuman Evaluasi:
- **Akurasi Tertinggi**: AdaBoost
- **Recall Tertinggi**: AdaBoost
- **AUC Tertinggi**: AdaBoost
- **Precision Tertinggi**: AdaBoost
- **F1-Score Tertinggi**: AdaBoost

---
✨ Model Terbaik:

**AdaBoost**merupakan model terbaik untuk tugas klasifikasi prediksi diabetes dibandingkan model yang telah dihasilkan lainnya karena performanya yang stabil dan konsisten

#### **Pengujian dengan data tes**
"""

# ambil 1 sampel dari data uji secara random
sample_idx = np.random.choice(X_test.index)
prediksi = X_test.loc[[sample_idx]].copy()
y_true_sample = y_test.loc[sample_idx]

# dictionary untuk menyimpan hasil prediksi
pred_dict = {'y_true': [y_true_sample]}

# loop setiap model untuk prediksi
for name, model in model_dict.items():
    pred = model.predict(prediksi)
    pred_dict[f'prediksi_{name}'] = pred

# print hasil prediksi
hasil_prediksi = pd.DataFrame(pred_dict)
print(hasil_prediksi)

# print data yang diprediksi sebelumnya
X_test.loc[[sample_idx]]